
# React


## ハンバーガー屋で隣の女子高生が語るReact 第1話 2020/01/29 18:15

https://note.com/erukiti/n/ne2a4eaafcf72  

ハンバーガー屋さんで隣の女子高生がReactを語っていました。

・ 第二話 隣の女子高生が語るデータの持ち方
・ 第三話 React Hooks
・ 予定 React Hooks チューニング
・ 予定 React 自動テスト

このシリーズを加筆・修正して、働きアップグレードガイド2020 〜楽しく働くために取り組めること〜という合同誌に収録することが決まりました。この合同誌、フルリモート・フルフレックスの会社でどうやって楽しく働くのか？2020年代の働き方についててんこ盛りの本なので、興味ある人はぜひチェックリストに追加してみてください。

Reactとは
R子「最近さー、うちReact書いてんねん」

　Reactは、Facebook社が開発しているウェブブラウザ向けのユーザーインターフェースライブラリ。同種のモノにVueやAngularなどがあるが、現時点で世界シェアトップはReactである。
J美「まじでー？jQueryじゃだめなん？」

　jQueryは、ウェブブラウザ戦争が激しかった頃に、ブラウザ間の互換性を取り持つことでシェアを拡大したライブラリ。昔としてはとても便利だった。プラグイン含め様々な情報やソースコード資源がある。
R子「ペライチなウェブサイト制作するならええけどー。真面目に開発しよー思たら、jQueryは治安悪すぎてしんどいよー」

　ここでいうペライチとは固有のサービスのことではなく、ペラ一枚、つまり単一ページか、それの組み合わせ程度で成り立つ昔ながらのウェブ制作のこと。ウェブというとこちらを想像する人が多い。単価は安くても案件としては多い（はず）
　治安とは、ソースコードがとっちらかったり、ルール無用であらゆる書き方やプラグインやライブラリやコピペなどが横行している状態。「ソースコードの治安が悪い」などと表現される。
J美「Reactって仮想DOMだっけ？あれってなんなん？魂震えるん？」

　仮想DOMは、ウェブブラウザの画面描画では、DOMの更新が動作を重くする原因であるため、Reactを使うプログラマはDOMを直接操作せずに、Reactのコンポーネント及びDOMのサブセットのようなものを操作する。Reactはこれらの操作を元に、最終的にDOMの書き換えを行う。賢いヤツ
　DOMは、Document Object Modelの略で、HTMLをJavaScriptから扱う時にアクセスするデータモデルだと思えばOK。
R子「うちらがやりたいのはDOM操作やのーて、ウェブブラウザを使ったアプリ開発やからなー。ReactみたいなSPAライブラリが流行ったのと、ブラウザ戦争が終結してくれたおかげで、めっちゃ楽になったんよー」

　DOM操作が主目的ならjQueryでもなんでもいいと思う。
　SPAはSingle Page Actionの略で、ページ遷移せずに画面が切り替わる技術のこと。これのおかげで、ウェブブラウザ上で、ネイティブアプリに近い操作感が得られるようになった。
　ブラウザ戦争があった頃は、各社が好き勝手やってたせいで、5年経っても仕様が固まらないなどといった停滞があった。
J美「DX改革だね」
R子「そうそう。今はもうウェブ開発ってVSCodeと優秀なライブラリのおかで、DXめっちゃアガってんねんよー」

　DXはここでは Developers eXperience 開発者体験の方。実際にここ数年でウェブフロントエンドを中心に、開発の快適さが急激に上昇している。特にMicrosoft社のOSSなIDEであるVSCodeは並のテキストエディタよりも軽量なのに、IDEとしての機能も十分で、ウェブ開発に最適である。最近はJavaなんかもサポートを強化している。
J美「最近やったらVueとかもいいんじゃないの？」
R子「ええーと思うよー。世界的なシェアは圧倒的にReactやけど、伸びてるのは間違いないでー。ウチはJSXがあるからReactの方が好きやけどねー」

　VueもReactみたいなやつ（語弊がある）Reactよりは高機能かつ、公式エコシステムが豊富な分、Reactよりはとっつきやすいと言われている。
　JSXは、JavaScript/TypeScriptのソースコードの中にHTMLタグのようなものを記述できる拡張。
J美「JSXってどうなん？あたしはHTMLテンプレート使う方がなじみやすいと思うんだけど」
R子「JSXは考え方がHTMLテンプレートとは逆やねんよー。HTMLやDOMってツリー状のデータ構造やん？そういうデータを扱うのは、プログラミング言語が元から普通にやってることやねんから、テンプレートっていう考え方でいちいち分けるよりは、プログラミングの一工程に混ぜ込む方がシンプルやねー」

　HTMLテンプレートの考え方はとても古くからあり、JSPやRailsなど多くのフレームワークで採用されている、おなじみのもの。HTMLの中に特殊な記法で変数名や、限定的なプログラムコード（DSLという）を書く。
　ツリー状のデータ構造とは、根っこ（root）から、幹が伸びて枝が広がって葉っぱがあるような、データ構造のこと。プログラミングでは標準的に使われる。
J美「HTMLテンプレートって分かりやすいと思うけど、JSXの利点ってプログラミングの工程に混ぜ込めることなの？」
R子「プログラミングの工程に混ぜ込むだけやと、あんまり利点わからんかもやねー。真価を発揮するのはリファクタリングとかやでー。HTMLテンプレートでリファクタリングするのはどうしても限界あるしなー」

　リファクタリングとは、「外からみた振る舞いを変更せずに、中身を書き換える」こと。外から見た振る舞いが変わってしまったら、それは決してリファクタリングではないことに要注意。
J美「リファクタリングってなんで必要なの？」
R子「プログラムを最初から完璧な状態で書くのが無理やからやでー。いつでも、慣れた同じものを作れるとは限らんし、そもそもビジネスの変化早い時代やねんから、一ヶ月で異なる要件出てくることもザラやし、実際のモノを作ったら、クライアントがコレジャナイって言い出すこともあるしねー」

画像1

J美「確かにプロトタイピングって重要だよね」

　プロトタイピングは人によって違うものを指す場合も多いが、中身は完成してなくても最小限の動きを実装し、なるべく実際のアプリケーションに近いものを作ることで、プロダクトについて判断できる人や企画者に動きを確認してもらう。
R子「リーンでいうMVP（仮説を検証する最小限のプロダクト）を短いサイクルでリリースして、仮説を立てて市場を伺いつつ検証するっていう考え方も当たり前になってきてるしなー。短いサイクルで効率的に開発しよう思たら、がっちり最初からキチキチに開発するよりはリファクタリングできるような開発を最初からしておいた方が後々楽なんやわー」

　リーン開発手法、大本はトヨタの生産手法に源流を置く、世界的な、ソフトウェア開発手法のこと。
　原則1：ムダをなくす
　原則2：品質を作り込む
　原則3：知識を作り出す
　原則4：決定を遅らせる
　原則5：速く提供する
　原則6：人を尊重する
　原則7：全体を最適化する
J美「HTMlテンプレートだとリファクタリングしづらい？」
R子「せやねー。HTMLテンプレートって、もともとの目的が非プログラマに触らせるためのもんやから、リファクタリングはほとんど考えられてないからなー。使い捨てならええけど、リファクタリングやるんなら、ユニットテストとかもある、ホンモノのプログラミング言語の方が絶対楽なんよー」

　ユニットテストは、単一機能を持った関数・メソッドなどを自動テストするための軽量な仕組み。JavaのJUnitやJavaScriptのJestなどがある。
　ホンモノのプログラミング言語じゃない環境で何か工夫しようとすると大体破綻する。

- - - 

## ハンバーガー屋で隣の女子高生が語るReact 第2話 データの持ち方 2020/01/29 19:30

ハンバーガー屋さんで隣の女子高生がReactにおけるデータの持ち方について語っていました。

・ 第一話 隣の女子高生が語るReact
・ 第三話 React Hooks
・ 予定 React Hooks チューニング
・ 予定 React 自動テスト

このシリーズを加筆・修正して、働きアップグレードガイド2020 〜楽しく働くために取り組めること〜という合同誌に収録することが決まりました。この合同誌、フルリモート・フルフレックスの会社でどうやって楽しく働くのか？2020年代の働き方についててんこ盛りの本なので、興味ある人はぜひチェックリストに追加してみてください。

データの持ち方
J美「R子がReactやってるっていうから触ってみたんだけど、Flux?Redux?って何なの？」
R子「FluxはReactに適したデータフローのアーキテクチャやねー。ReduxはFluxの考え方の大半を実装したライブラリで、MVCとかMVVMが抱えていた根本的な複雑性を解決する冴えたやり方やねー。コツはデータの流れを一方通行にすることと、受け口が一箇所に定まってることやなー」

　データフローは、データの流れる向きや順序のこと。プログラミングにおいてはデータがどう流れて制御が移っていくかを追いかけると理解しやすい
　アーキテクチャは、広い意味を持つ言葉だけど、ここでは大きい枠組みくらいに捉えておくと吉。
　Fluxは、MVC/MVVMなどが抱えていた、多対多の関係性をなくすために、データの流れを一方通行にすることで簡単にしようぜというアイデア。React と対になるように、Facebook社員が提唱したもの。
　MVCやMVVMは、度々ファットコントローラ、ファットモデルなど、特定の層に処理が集中するアンチパターンが生じがちだったり、それぞれのレイヤーのコンポーネントが、別のレイヤーの複数のコンポーネントと関係性を持つ、多対多の構造になりやすく、複雑性を持つという仕組み上の欠陥を持っていた。
　Reduxは、Fluxが提唱されてから、一番シェアを持っているライブラリ。
J美「データの流れが一方通行ってどういうこと？」
R子「MVCとか既存のアーキテクチャやと、それぞれの役割のコンポーネントが相互にデータを投げ合うけど、Flux/Reduxではそれぞれのコンポーネントは、好き勝手にデータを投げたらあかんねんよー」
R子「例えばUIの最前線はもちろんビュー（Reactのコンポーネント）やけど、Fluxでのビューは自分で状態更新はしたらあかんねん。できるのんはビューのイベント（マウスクリックとかキーを押したとか）に応じて、アクションっていうプレインオブジェクトを、ディスパッチャに投げることだけやねー（※1）。」

　※1 正確には、React コンポーネントに引数で渡ってきた関数を叩くのはあり。というか、もともとReactの考え方で、引数で渡ってきた関数を叩くことでツリーの根っこに近い方で状態管理できるようにするというものだった。よく props のバケツリレーなどと言われるもの。
　プレインオブジェクトは、JavaだとPOJOとも言われるもの。JavaScriptだとJSON化できるオブジェクトというと分かりやすいか。要するに基本的な最小限のデータ（文字列、数字、真偽値、配列などで構成されるツリー状のデータ構造）
　ディスパッチャとは、その関数を実行することで、決められた1つの場所にデータを渡すことができるという、交通整理できる優れた便利関数。
R子「非同期処理なんかも、API通信とかの結果をダイレクトにビューの更新をするわけじゃなくて、同じようにディスパッチャに投げるんやなー。Reduxの場合は非同期処理をするためのミドルウェアがあんでー」

　　非同期ミドルウェアとは、React + Redux だけではAPIアクセスなどの非同期処理が綺麗にさばけないため使われるもの。Reduxは、とても簡単にミドルウェアを追加できるため、様々なミドルウェアが存在する。redux-saga や redux-thunk などが有名。
J美「つまり直接データを書き換えるんじゃなくて、アクションっていう、データを書き換えるためのデータを作って、ディスパッチャに投げるっていう間接操作でやるってこと？なんでそんな面倒なことするん？」
R子「データを直接書き換えると、データの書き換え方のルールを決められへんやろ？たとえば、データ作成の時間情報を更新するときに、Date型を入れたり、UNIX time入れたり、UNIX timeのミリ秒入れたり、なんでも出来てしまうやん？」
J美「でもそれだけなら、データモデルをTypeScriptで記述すれば型で制約かけるんじゃない？」
R子「UNIX timeの秒とミリ秒とかだと、TypeScriptでは同じモノに見えてまうからなー。でもディスパッチャ経由にして、ワンクッションおけばユニットテストなんかも書きやすくなるやろー」

　Date型は、JavaScriptで日時を表現するオブジェクト。機能が乏しく操作が面倒なため、度々momentみたいな便利ライブラリが使われる。
　UNIX time （epoch エポックとも言う）は、1970年1月1日0時0分からの通算時刻を秒で表現したもの。ただし、JavaScriptでは秒単位ではなくミリ秒単位で表現したものが主に使われる。そのため、APIなどで秒単位のUNIX time を取得したときには、JavaScript向けにミリ秒やDate型に、データ変換をすることになる。
　TypeScript は、Microsoft社が開発するJavaScriptの完全上位互換かつ、静的型付けをサポートしたハイブリッド言語。最近のJavaScript開発では半分以上のシェアを占めている事実上の標準。
J美「ユニットテストはどういう風に書くん？」
R子「たとえば、アクションを生成するアクションクリエイターのテストやなー。APIの結果から、データモデルを変更するためのミリ秒の数値を生成できるかどうかテストしたりとかやなー。」
J美「なんかまた登場人物増えたね。アクションクリエイタは関数？」
R子「せやねー。ビューのイベントや、非同期処理の結果を、アクションクリエータに食わせて、アクションの生成やディスパッチをするんや。登場人物は確かに増えるけど、通り道が限定されるから、ユニットテストが書きやすくなるし、バグに対処しやすくなるよー」

　実際にはここらへんはバランス感覚が重要なところ。通り道が限定されるのがいいのか？レイヤーが増えることで複雑に感じるか？ユニットテストをどれくらい重視するのか？など、アーキテクトの腕の見せ所である。
J美「関数型プログラミング的な考え方ってやつ？」
R子「せやねー。コンピュータの仕組みまで遡ると、プログラムは基本的にはデータ変換がお仕事やからねー。APIやビューのデータを、アクションに変換する関数って考えると、シンプルかつ堅牢なものにできるやろー」

　関数型プログラミング、ここでは基本的に純粋関数と呼ばれる、入力が同一なら出力が必ず同一になるもの、かつ副作用（わかりやすいものはI/O）を持たないもので、アクションクリエイターは作成可能。そもそもやってることシンプルなんだし。
J美「アクションやディスパッチは分かったけど、ディスパッチされたアクションはどうなるん？」
R子「ディスパッチされたアクションは、ストアに配送されんねんよ。Reduxとかだと、ストアにはReducer（リデューサ）っていう、アクションの応じてデータモデルを変更する関数を登録しておいて、リデューサがデータを書き換えるんよ」

　ストアは、データを貯めるところであり、かつ登録されたリデューサによってデータの変換の過程を保証する装置。
J美「ストアがデータを書き換えたとして、そのあとどうなんの？それだけだとビューの状態変わんないでしょ？」
R子「大前提として、ビューに渡るデータは全部ストアが管理しとんねんよー。デザインパターンでいうObserverパターンやねんけど、ストアでデータが更新されたら、ビュー、つまりReactに渡すデータを書き換える。そしたらReactのライブラリがビューの状態を変えるんやなー」

　Observerパターンは、デザインパターンの一種で、値が更新したり、なにがしかのイベントに応じて登録したコールバック関数を実行するというもの。イベントドリブンプログラミングやGUIなどでは当たり前のように使われるパターンでもある。
J美「なるほど。ビューのイベントハンドラや、非同期処理の結果は、アクションクリエイターが作ったアクションをディスパッチして、ストアはディスパッチされたアクションでデータを更新する。そうしたらストアはReactコンポーネントに渡すデータを更新することで、ビューの状態が更新されるんだね。なんかめんどくさくない？」
R子「ぶっちゃけ構造全体を見ると面倒くさいというか大げさに見えるけど、MVCやMVVMよりは交通整理されてるだけマシやと思うわ。あと、ここまで説明してなんやねんけど、今のReactは、Flux/Reduxより先の世界にいってるから、もっとシンプルになっとんねんよ」

- - - 

## ハンバーガー屋で隣の女子高生が語るReact 第3話 Hooks 2020/01/30 15:30

https://note.com/erukiti/n/ne91d53d64e86  

ハンバーガー屋さんで隣の女子高生がReact Hooksについて語っていました。

・ 第一話 React
・ 第二話 隣の女子高生が語るデータの持ち方
・ 予定 React Hooks チューニング
・ 予定 React 自動テスト

このシリーズを加筆・修正して、働きアップグレードガイド2020 〜楽しく働くために取り組めること〜という合同誌に収録することが決まりました。この合同誌、フルリモート・フルフレックスの会社でどうやって楽しく働くのか？2020年代の働き方についててんこ盛りの本なので、興味ある人はぜひチェックリストに追加してみてください。

データの流れが明確化したことで訪れた変化
J美「さっき、Reactはもっとシンプルになってるって言ってたけど、どんな風にシンプルになったん？」
R子「元々Reactが生まれたときって、Reactコンポーネントは自前の状態（ステート）を持ちつつ、ツリーの根っこから渡されるハンドラによって、自分の状態更新を自分の親やそのさらに親に伝えとってんよー。ただ、そんときは当然、MVVMとかと変わらん複雑さがあったわけやな ー」

　Reactは元々、コンポーネントに渡された引数によって仮想DOMを操作し、渡されたハンドラによって状態を更新するという考えで作られていて、それがまさにリアクティブプログラミングだったためにReactという名称がつけらている
　リアクティブプログラミングはたとえば、Excelなんかがそうだが、あるセルの値が書き換わると、それに応じて他のセルも変更される。Reactでも、あるコンポーネントの引数やイベントによって他の状態も変化するという構造である。
J美「Flux/Reduxがデータの交通整理を他が引き受けてくれたから、Reactの構造自体がそこまでややこしいことをしなくて済むようになったってこと？」
R子「せやねー。Reactが当初考えてたよりもシンプルにやってもいいってみんな気づいたんよー。最初のReactはクラス型コンポーネントで複雑だけど高機能やったけど、そういう理由で、途中から関数型コンポーネントっていう、純粋関数を使うようになったんやねー」

　クラス型コンポーネントは、昔のReactコンポーネントの作成方法で、React.Component を継承したクラスのこと。
 　関数型コンポーネントは、単一の関数がコンポーネントになるというもの。
J美「さっきから純粋関数ってよく出てくるけど、なんで純粋関数が出てくんの？そもそも純粋ってなんなの？ピュアなん？」
R子「純粋関数って、副作用とかが無くて、入力によって出力が確定する関数のことやねんけど、これの利点は仕様が分かりやすいことと、ユニットテストがめっちゃ書きやすいことやねー。特にReactの純粋関数コンポーネントやったら、引数を JSX のツリー構造に変換するだけのプログラムになるから、デバッグもテストも開発も簡単になるんよー」

　純粋関数。関数型言語の人たちが好むやつ。Reduxなんかも実は制約として、引数を書き換えちゃいけないというルールがあったりする。
　副作用はプログラミング中級者以上を目指すなら、覚えておくべき概念。I/Oや、配列やオブジェクトの中身の書き換え、変数の書き換えなどはすべて副作用。ちなみに純粋関数でI/Oを行うためには、ちょっとした概念の導入が必要になるが、関数型言語を布教する記事ではないため省略する。
　ユニットテストでは、副作用は極めて厄介な存在である。対処方法としてはモックを使うなど。
R子「ただなー。Flux/Redux + 純粋関数だとどうしても問題があってなー。仰々しすぎて、どうせならコンポーネント自体が状態を持つ方が好ましいときってのがあんねんよー」
J美「Inputコンポーネントで使うような現在入力中の文字列とかって、ストアで持つのはさすがにアホらしいもんね？」
R子「そうそう。Flux/Reduxは素晴らしい革命的なヤツやったけど、なんでもかんでもストアにデータ貯めるのって、それはそれでアンチパターンやねんよー」

　アンチパターン。みんながハマりがちなパターンのこと。Reduxなんかはシングルストア・シングルソースという概念を持つため、ある一つの場所に、細々した情報すらため込まれるため、ぶっちゃけ、無駄に仰々しい。Reactが難しいって感じたら、だいたいReduxアンチパターンのせいだと思っていい。
J美「それどうやって解決すんの？今までのReactやFlux/Reduxの仕組みじゃどうしようもなさそうだし、せっかくFlux/Reduxで簡単になったものが逆戻りしちゃいそうなんだけど」
R子「そこで一時期流行ったんが、Recompose/HoCっていう考え方やねんなー。JavaScriptって元々関数型言語の流れをくむ言語っていうのもあって、高階関数を合成することで、純粋関数コンポーネントに、状態を持つ機能を後付けする仕組みやね」

　高階関数自体はJavaScriptだと当たり前のように使われている。関数やメソッドの引数に関数を指定するというもの。これはJSでは最初期からそうなっていたが、古い言語の中には関数を自由にやり取りできないものもあった。
　高階関数の合成、要するに引数として受け取った関数と別の関数を足し合わせて、ある純粋関数に別の機能をアドインするようなもの。純粋関数自体は綺麗なままで、状態保持や副作用を合成する別の関数に押し付けたりできる。
J美「じゃぁ、React + Redux + 非同期ミドルウェア + Recompose / HoC っていう組み合わせが流行ってたの？」
R子「そうそう。一部の意識高い系React民に好まれてたんやわー」
J美「でも、それってただでさえ複雑になってたReact + Redux が、さらにややこしくなるってことよね？」
R子「せやねー。結局のところ、純粋関数は便利だけど、機能追加をRecompose/ HoC のやり方でやるのは大変やから、React自体に大きくメスを入れたんよー。それがReact Hooksっていう、Reactの関数型コンポーネントに、状態とか副作用をもたせつつも、純粋関数のときとほぼ同様のメリットを享受できる仕組みやねん」

　React + Redux + 非同期ミドルウェア + Recompose / HoC は正確にはコンポーネントは全部純粋関数で書いたうえで、Recompose というライブラリによって、機能を合成していた。
　React Hooksは、React 自体が Recompose のような機能を React 内部をいじることで実現したもの。そりゃ本家本元が React 自体いじる方が確実だ。
J美「React HooksとRecomposeでシェア争いみたいにはならなかったの？」
R子「それがなー。Recomposeの作者もReduxの作者もFacebooks社に入社して React Hooksの開発者側に回ったから、シェア争い以前に趨勢が決まったんよー。Facebook社もうまいこと立ち回ったもんやわー」

　ちなみにRecomposeの開発はもうされないらしい。そりゃまぁそうだろう。
J美「それはそれとしてReact Hooksはどういう機能持ってるん？」
R子「React HooksはHooks関数っていう、特定の条件でのみ使える特殊な関数を提供しとってなー。具体的には関数型コンポーネントかつ、その関数のトップレベルであることやな。あとHooks関数はかならず use から始まる」
J美「トップレベルって？？」
R子「if/for文とコールバック関数以外の場所かな。制御構造の内側は禁止されてるってことやね」

　Hooks関数は、R子が言ったように、特定条件でのみ使える関数で、かつ、useという名前から始まる関数。
　トップレベルと言っても、ソースコード自体のとトップレベルではなくて、関数でのトップレベルのこと。一段でも何かしらの制御構造などでネストされるとだめ。
　コールバック関数は、JavaScriptだと空気のごとく度々登場するやつ。ある関数を実行するときに、処理が終わったとき、他のイベントが生じたとき、エラーが生じたときなどに呼び出される。
J美「だめなパターンいくつか教えてよ」
R子「せやな。こういうのは実際のコードで見たほうがわかりやすいなー」

```
import React, { useEffect } from 'react'

const Component = props => {
  useEffect(() => {
    console.log('これはOK')
  }, [])

  if (props.hoge) {
    useEffect(() => {
      console.log('これはNG 1')
    }, [])
  }

  for (const line of props.lines) {
    useEffect(() => {
      console.log('これはNG 2'）
    }, [])
  }

  props.line.forEach(line => {
    useEffect(() => {
      console.log('これはNG 3')
    }, [])
  })

  return <div>J美大好き！</div>
}
```

R子「NG 1はif文の中やねー。もちろんelseの中でもあかんよー」
R子「NG 2はfor文の中やねー。もちろんwhileの中でもあかんよー」
R子「NG 3はコールバックの中やねー。コールバック関数の中は結構、ナチュラルにhooks関数を書きそうになる罠やでー」
J美「これって結構制約キツくない？」
R子「まー、実際考え方をスイッチせんといかんやろねー」

　JavaScriptに限らずだが、ブロックスコープの外側の変数は、クロージャーという概念の元アクセス可能になるため、そういった概念を活用する必要がある。
J美「なんでhooks関数って、こんなに条件厳しいの？」
R子「hooks関数って、Reactコンポーネントに依存した仕組みやねんけど、普通のJavaScriptプログラミングやと、ある純粋な関数が、そのコンテキストに応じて処理内容変えるってできへんやろ？」
J美「Scalaだったら implicit 引数でコンテキスト渡したりするよね」
R子「せやなー。いうてもScalaやないから、JavaScript/TypeScriptでどうにかせんといかんねん。そしたらReact自体のコンポーネント階層の情報を使って、関数にコンテキストを注入するやり方になるわけやなー」
J美「なるほど、技術的な理由ってことね」

　Scalaのimplicit引数は、筆者は個人的にはかなり嫌いな存在なのだが、便利な側面もある。わざわざ関数の引数に、変数を指定しなくても暗黙的に引き回されるといった便利機能である。ややこしい操作を意識しなくても勝手に必要な情報が渡っている。implicit引数が無い多くの言語ではたとえば context みたいな引数を渡すこともある。こういったことは設計のトレードオフとして捉えられることが多い。
　Reactというライブラリから見れば、コンポーネント関数はツリー構造で管理されていて、それぞれのコンポーネント関数はどういうコンテキストを持っているか？というのを知っている。コンテキストはたとえば、自分の親はどういうコンポーネントか？今保持してるステートというようなもの。クラスとインスタンスの関係に似ている。コンポーネント関数はコンテキストと合わさって、ある1つのインスタンスのように扱われる。
　ここに制御構造が合わさるとコンポーネントツリーだけではコンテキストを管理できなくなってしまうため、技術的に極めて面倒な話になるから、制御構造を入れたくないというのはある。
R子「じつはそれだけやないんやけどねー。トップレベルに限定されるのは、制御構造を入れて複雑にしたくなかったっていう意図もあんねんよー」
J美「というと？」
R子「制御構造を許したら、人類には難しすぎるものになっちゃうからやねー。React Hooksプログラミングでは、関数型コンポーネントのトップレベルでやることって3種類だけやねんよー。元からの目的であるJSXを返すこと、データを受け取ること、コールバック関数の登録やねー。こうすることで考え方をシンプルにして、人類でも簡単に扱えるようにしたんやねー」

　純粋関数以外の側面を hooks に押し付けた形なのだが、たとえば副作用なんかはコールバック関数の中で実行してもいいというふうにしておけば良い。
　先程も述べたが純粋関数には、ユニットテストが書きやすいなどの利点がある。登録されたコールバック関数のテストを考えずにテストが可能になる。
J美「もし副作用を関数型コンポーネントのトップレベルに書いたらどうなるん？」
R子「副作用を検知する仕組み自体は無いから、その副作用次第やねー。console.log だけなら、console.log でコンソールがにぎやかになるだけかもしれんねー。ただそれで重くなることもあるかもしれへんよー。あと、下手なことやると無限ループが簡単に生じたりするでー」
J美「無限ループ？どういう場合に生じるの？」
R子「一番わかり易いのは、ステート更新をトップレベルでやっちゃうことやな。ステート更新って、関数を実行しなおして新しい状態に更新するっていうフローやから、自分で自分を更新し続けるねんよー」

　詳しいことはまた次の話にしたいと思うが、基本的にReact Hooksの関数型コンポーネントのトップレベルでは、余計なことをしない。最小限の変換のみを行うというのが鉄則となる。
J美「ところでhooks関数ってどんなのがあるん？」
R子「よく使うのは、useState, useEffect, useCallback かなー。あとは状況によって useLayoutEffect, useMemo, useRef, useContext を引き出しに入れておけばほとんどケースは対処できるよー」

　詳しくは、実際に、公式のAPIリファレンスを見てほしい。ただ、全部を使うことはそうそうない。
J美「関数名からなんとなく想像できるけど、useStateは、ステート、つまり状態を持つ関数で、useEffect は side effect（副作用）を実現するもの、useCallback はコールバック関数作るためのものってことで合ってる？」
R子「合ってる合ってるよー。クラス型コンポーネントのときも、propsとstateがあって、stateはコンポーネントローカルの状態のことだったけど、hooksでもその点は同じ。アコーディオンコンポーネント作ったとして、アコーディオンの状態を自分以外にもたせてもしゃーないから、自分自身でステートとして持つってことやねー。」
R子「大体React Hooksでコンポーネント作ってると、色々な処理が useEffect の中に入ることになるねー。API呼び出しをuseEffectの中に書いて、結果を取得したらその結果で、ステート更新したりする感じー。」
J美「ところで、コールバック関数は分かるんだけど、わからんない。なんでコールバック関数作るためのhooks関数がわざわざ用意されてるん？」
R子「useCallbackがあるのって、どちらかというとパフォーマンスチューニングが理由やねん。これはまた今度詳しく話すわー」





